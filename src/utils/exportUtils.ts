// Export utilities for PDF and Excel generation

export interface ExportData {
  title: string
  headers: string[]
  rows: (string | number)[][]
  metadata?: {
    generatedAt: Date
    generatedBy: string
    period?: string
  }
}

// PDF Export using jsPDF
export const exportToPDF = async (data: ExportData, filename?: string) => {
  try {
    // Dynamic import to reduce bundle size
    const { jsPDF } = await import('jspdf')
    const { autoTable } = await import('jspdf-autotable')
    
    const doc = new jsPDF()
    
    // Add title
    doc.setFontSize(20)
    doc.text(data.title, 14, 22)
    
    // Add metadata
    if (data.metadata) {
      doc.setFontSize(10)
      doc.text(`Generated: ${data.metadata.generatedAt.toLocaleDateString()}`, 14, 30)
      doc.text(`Generated by: ${data.metadata.generatedBy}`, 14, 35)
      if (data.metadata.period) {
        doc.text(`Period: ${data.metadata.period}`, 14, 40)
      }
    }
    
    // Add table
    autoTable(doc, {
      head: [data.headers],
      body: data.rows,
      startY: data.metadata ? 50 : 30,
      styles: {
        fontSize: 10,
        cellPadding: 5,
      },
      headStyles: {
        fillColor: [102, 126, 234], // Purple color
        textColor: 255,
        fontStyle: 'bold',
      },
      alternateRowStyles: {
        fillColor: [245, 245, 245],
      },
    })
    
    // Save the PDF
    const finalFilename = filename || `${data.title.replace(/\s+/g, '_')}_${new Date().toISOString().split('T')[0]}.pdf`
    doc.save(finalFilename)
    
    return { success: true, filename: finalFilename }
  } catch (error) {
    console.error('PDF export error:', error)
    return { success: false, error: 'PDF export failed' }
  }
}

// Excel Export using xlsx
export const exportToExcel = async (data: ExportData, filename?: string) => {
  try {
    // Dynamic import to reduce bundle size
    const XLSX = await import('xlsx')
    
    // Create workbook
    const wb = XLSX.utils.book_new()
    
    // Prepare data for Excel
    const excelData = [
      [data.title], // Title row
      [], // Empty row
    ]
    
    // Add metadata if available
    if (data.metadata) {
      excelData.push([`Generated: ${data.metadata.generatedAt.toLocaleDateString()}`])
      excelData.push([`Generated by: ${data.metadata.generatedBy}`])
      if (data.metadata.period) {
        excelData.push([`Period: ${data.metadata.period}`])
      }
      excelData.push([]) // Empty row
    }
    
    // Add headers and data
    excelData.push(data.headers)
    excelData.push(...data.rows.map(row => row.map(cell => String(cell))))
    
    // Create worksheet
    const ws = XLSX.utils.aoa_to_sheet(excelData)
    
    // Set column widths
    const colWidths = data.headers.map(() => ({ wch: 20 }))
    ws['!cols'] = colWidths
    
    // Add worksheet to workbook
    XLSX.utils.book_append_sheet(wb, ws, 'Data')
    
    // Save the Excel file
    const finalFilename = filename || `${data.title.replace(/\s+/g, '_')}_${new Date().toISOString().split('T')[0]}.xlsx`
    XLSX.writeFile(wb, finalFilename)
    
    return { success: true, filename: finalFilename }
  } catch (error) {
    console.error('Excel export error:', error)
    return { success: false, error: 'Excel export failed' }
  }
}

// CSV Export (simpler, no external dependencies)
export const exportToCSV = (data: ExportData, filename?: string) => {
  try {
    const csvContent = [
      data.title,
      '',
      ...(data.metadata ? [
        `Generated: ${data.metadata.generatedAt.toLocaleDateString()}`,
        `Generated by: ${data.metadata.generatedBy}`,
        ...(data.metadata.period ? [`Period: ${data.metadata.period}`] : []),
        ''
      ] : []),
      data.headers.join(','),
      ...data.rows.map(row => row.join(','))
    ].join('\n')
    
    // Create and download file
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' })
    const link = document.createElement('a')
    const url = URL.createObjectURL(blob)
    
    link.setAttribute('href', url)
    const finalFilename = filename || `${data.title.replace(/\s+/g, '_')}_${new Date().toISOString().split('T')[0]}.csv`
    link.setAttribute('download', finalFilename)
    link.style.visibility = 'hidden'
    
    document.body.appendChild(link)
    link.click()
    document.body.removeChild(link)
    
    return { success: true, filename: finalFilename }
  } catch (error) {
    console.error('CSV export error:', error)
    return { success: false, error: 'CSV export failed' }
  }
}

// Dashboard data export helpers
export const exportDashboardData = {
  // Export customer feedback data
  customerFeedback: (feedbackData: any[]) => {
    return {
      title: 'Customer Feedback Report',
      headers: ['Date', 'Customer', 'Rating', 'Comment', 'Sentiment', 'Category'],
      rows: feedbackData.map(feedback => [
        new Date(feedback.date).toLocaleDateString(),
        feedback.customer || 'Anonymous',
        feedback.rating || 'N/A',
        feedback.comment || '',
        feedback.sentiment || 'Neutral',
        feedback.category || 'General'
      ]),
      metadata: {
        generatedAt: new Date(),
        generatedBy: 'Qratex Dashboard',
        period: 'All Time'
      }
    }
  },
  
  // Export analytics data
  analytics: (analyticsData: any) => {
    return {
      title: 'Analytics Report',
      headers: ['Metric', 'Value', 'Change', 'Period'],
      rows: [
        ['Total Feedback', analyticsData.totalFeedback || 0, analyticsData.feedbackChange || '0%', 'This Month'],
        ['Average Rating', analyticsData.averageRating || 0, analyticsData.ratingChange || '0%', 'This Month'],
        ['Positive Sentiment', analyticsData.positiveSentiment || '0%', analyticsData.sentimentChange || '0%', 'This Month'],
        ['Response Rate', analyticsData.responseRate || '0%', analyticsData.responseChange || '0%', 'This Month']
      ],
      metadata: {
        generatedAt: new Date(),
        generatedBy: 'Qratex Dashboard',
        period: 'Monthly Report'
      }
    }
  },
  
  // Export badge data
  badges: (badgeData: any[]) => {
    return {
      title: 'Badge Collection Report',
      headers: ['Badge Name', 'Category', 'Rarity', 'Points', 'Unlocked Date', 'Description'],
      rows: badgeData.map(badge => [
        badge.name || 'Unknown',
        badge.category || 'General',
        badge.rarity || 'Common',
        badge.points || 0,
        badge.unlockedAt ? new Date(badge.unlockedAt).toLocaleDateString() : 'Not Unlocked',
        badge.description || ''
      ]),
      metadata: {
        generatedAt: new Date(),
        generatedBy: 'Qratex Dashboard',
        period: 'All Time'
      }
    }
  }
}